// Generated by CoffeeScript 1.10.0

/*

bump.js

Copyright (c) 2013 Jairo Luiz
Licensed under the MIT license.
 */

(function() {
  var Bump, HashMap,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Array.prototype.remove = function(item) {
    var from, rest;
    from = this.indexOf(item);
    rest = this.slice(from + 1, this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
  };

  HashMap = (function() {
    HashMap._currentItemId = 1;

    function HashMap() {
      this._dict = {};
      this._keys = {};
    }

    HashMap.prototype.put = function(key, value) {
      if (typeof key === "object") {
        if (key._hashKey == null) {
          key._hashKey = "object:" + (HashMap._currentItemId++);
        }
        this._dict[key._hashKey] = value;
        return this._keys[key._hashKey] = key;
      } else {
        return this._dict[key] = value;
      }
    };

    HashMap.prototype.get = function(key) {
      if (typeof key === "object") {
        return this._dict[key._hashKey];
      } else {
        return this._dict[key];
      }
    };

    HashMap.prototype.remove = function(key) {
      if (typeof key === "object") {
        return delete this._dict[key._hashKey];
      } else {
        return delete this._dict[key];
      }
    };

    HashMap.prototype.values = function() {
      var _, ref, results, value;
      ref = this._dict;
      results = [];
      for (_ in ref) {
        value = ref[_];
        results.push(value);
      }
      return results;
    };

    HashMap.prototype.keys = function() {
      var _, key, ref, results;
      ref = this._dict;
      results = [];
      for (key in ref) {
        _ = ref[key];
        results.push(this._keys[key] || key);
      }
      return results;
    };

    return HashMap;

  })();

  Bump = (function() {
    var _boxesIntersect, _collectItemsInRegion, _collideItemWithNeighbor, _collideItemWithNeighbors, _each, _eachCellInRegion, _eachInRegion, _getCell, _getMaximumAreaOverlap, _getNeighbors, _getNextCollisionForItem, _getOverlapAndDisplacementVector, _getOverlaps, _invokeEndCollision, _registerItem, _toGrid, _toGridBox, _toGridFromInside, _unregisterItem, _updateItem;

    Bump.DEFAULT_CELL_SIZE = 128;

    function Bump(_cellSize) {
      this._cellSize = _cellSize != null ? _cellSize : Bump.DEFAULT_CELL_SIZE;
      this._cells = [];
      this._items = new HashMap();
      this._prevCollisions = new HashMap();
    }

    Bump.prototype.collision = function(item1, item2, dx, dy) {};

    Bump.prototype.endCollision = function(item1, item2) {};

    Bump.prototype.shouldCollide = function(item1, item2) {
      return true;
    };

    Bump.prototype.getBBox = function(item) {
      return item.getBBox();
    };

    Bump.prototype.add = function(item) {
      this._items.put(item, this._items.get(item) || {});
      return _updateItem.call(this, item);
    };

    Bump.prototype.addStatic = function(item) {
      this.add(item);
      return this._items.get(item)["static"] = true;
    };

    Bump.prototype.remove = function(item) {
      _unregisterItem.call(this, item);
      return this._items.remove(item);
    };

    Bump.prototype.collide = function(l, t, w, h) {
      _each.call(this, _updateItem, l, t, w, h);
      this._collisions = new HashMap;
      this._tested = new HashMap;
      _each.call(this, _collideItemWithNeighbors, l, t, w, h);
      _invokeEndCollision.call(this);
      return this._prevCollisions = this._collisions;
    };

    _each = function(func, l, t, w, h) {
      return _eachInRegion.call(this, func, _toGridBox.call(this, l, t, w, h));
    };

    _toGrid = function(wx, wy) {
      return [Math.floor(wx / this._cellSize) + 1, Math.floor(wy / this._cellSize) + 1];
    };

    _toGridFromInside = function(wx, wy) {
      return [Math.ceil(wx / this._cellSize), Math.ceil(wy / this._cellSize)];
    };

    _toGridBox = function(l, t, w, h) {
      var gb, gl, gr, gt, ref, ref1;
      ref = _toGrid.call(this, l, t), gl = ref[0], gt = ref[1];
      ref1 = _toGridFromInside.call(this, l + w, t + h), gr = ref1[0], gb = ref1[1];
      return [gl, gt, gr - gl, gb - gt];
    };

    _updateItem = function(item) {
      var gh, gl, gt, gw, h, info, l, ref, ref1, ref2, ref3, ref4, t, w;
      info = this._items.get(item);
      if (!info || info["static"]) {
        return;
      }
      ref = this.getBBox(item), l = ref[0], t = ref[1], w = ref[2], h = ref[3];
      if ((l !== info.l) || (t !== info.t) || (w !== info.w) || (h !== info.h)) {
        ref1 = _toGridBox.call(this, l, t, w, h), gl = ref1[0], gt = ref1[1], gw = ref1[2], gh = ref1[3];
        if ((gl !== info.gl) || (gt !== info.gt) || (gw !== info.gw) || (gh !== info.gh)) {
          _unregisterItem.call(this, item);
          ref2 = [gl, gt, gw, gh], info.gl = ref2[0], info.gt = ref2[1], info.gw = ref2[2], info.gh = ref2[3];
          _registerItem.call(this, item);
        }
        ref3 = [l, t, w, h], info.l = ref3[0], info.t = ref3[1], info.w = ref3[2], info.h = ref3[3];
        return ref4 = [l + w * 0.5, t + h * 0.5], info.cx = ref4[0], info.cy = ref4[1], ref4;
      }
    };

    _unregisterItem = function(item) {
      var info;
      info = this._items.get(item);
      if (info && info.gl) {
        if (info.unregister == null) {
          info.unregister = function(cell) {
            return cell.remove(item);
          };
        }
        return _eachCellInRegion.call(this, info.unregister, info.gl, info.gt, info.gw, info.gh);
      }
    };

    _registerItem = function(item, gl, gt, gw, gh) {
      var info;
      info = this._items.get(item);
      if (info.register == null) {
        info.register = function(cell) {
          return cell.push(item);
        };
      }
      return _eachCellInRegion.call(this, info.register, info.gl, info.gt, info.gw, info.gh, true);
    };

    _eachCellInRegion = function(func, gl, gt, gw, gh, create) {
      var cell, gx, gy, i, ref, ref1, results;
      results = [];
      for (gy = i = ref = gt, ref1 = gt + gh; ref <= ref1 ? i <= ref1 : i >= ref1; gy = ref <= ref1 ? ++i : --i) {
        results.push((function() {
          var j, ref2, ref3, results1;
          results1 = [];
          for (gx = j = ref2 = gl, ref3 = gl + gw; ref2 <= ref3 ? j <= ref3 : j >= ref3; gx = ref2 <= ref3 ? ++j : --j) {
            cell = _getCell.call(this, gx, gy, create);
            if (cell) {
              results1.push(func.call(this, cell, gx, gy));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    _getCell = function(gx, gy, create) {
      var base, base1, ref;
      if (!create) {
        return (ref = this._cells[gy]) != null ? ref[gx] : void 0;
      }
      if ((base = this._cells)[gy] == null) {
        base[gy] = [];
      }
      if ((base1 = this._cells[gy])[gx] == null) {
        base1[gx] = [];
      }
      return this._cells[gy][gx];
    };

    _eachInRegion = function(func, gl, gt, gw, gh) {
      var i, item, len, ref, results;
      ref = _collectItemsInRegion.call(this, gl, gt, gw, gh);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(func.call(this, item));
      }
      return results;
    };

    _collectItemsInRegion = function(gl, gt, gw, gh) {
      var collect, items;
      if (!(gl && gt && gw && gh)) {
        return this._items.keys();
      }
      items = [];
      collect = function(cell) {
        if (cell) {
          return items = items.concat(cell);
        }
      };
      _eachCellInRegion.call(this, collect, gl, gt, gw, gh);
      return items;
    };

    _collideItemWithNeighbors = function(item) {
      var dx, dy, finished, info, neighbor, ref, ref1, results, visited;
      info = this._items.get(item);
      if (!info || info["static"]) {
        return;
      }
      visited = [];
      finished = false;
      ref = [null, 0, 0], neighbor = ref[0], dx = ref[1], dy = ref[2];
      results = [];
      while (this._items.get(item) && !finished) {
        ref1 = _getNextCollisionForItem.call(this, item, visited), neighbor = ref1[0], dx = ref1[1], dy = ref1[2];
        if (neighbor) {
          visited.push(neighbor);
          results.push(_collideItemWithNeighbor.call(this, item, neighbor, dx, dy));
        } else {
          results.push(finished = true);
        }
      }
      return results;
    };

    _collideItemWithNeighbor = function(item, neighbor, dx, dy) {
      this._collisions.put(item, this._collisions.get(item) || []);
      this._collisions.get(item).push(neighbor);
      this.collision(item, neighbor, dx, dy);
      if (this._prevCollisions.get(item)) {
        this._prevCollisions.get(item).remove(neighbor);
      }
      _updateItem.call(this, item);
      _updateItem.call(this, neighbor);
      this._tested.put(item, this._tested.get(item) || []);
      return this._tested.get(item).push(neighbor);
    };

    _getNextCollisionForItem = function(item, visited) {
      var neighbors, overlaps;
      neighbors = _getNeighbors.call(this, item, visited);
      overlaps = _getOverlaps.call(this, item, neighbors);
      return _getMaximumAreaOverlap.call(this, overlaps);
    };

    _getNeighbors = function(item, visited) {
      var i, info, len, nbors, v;
      info = this._items.get(item);
      nbors = _collectItemsInRegion.call(this, info.gl, info.gt, info.gw, info.gh);
      nbors.remove(item);
      for (i = 0, len = visited.length; i < len; i++) {
        v = visited[i];
        nbors.remove(v);
      }
      return nbors;
    };

    _getOverlaps = function(item, neighbors) {
      var area, dx, dy, i, info, len, neighbor, ninfo, overlaps, ref, ref1;
      overlaps = [];
      info = this._items.get(item);
      ref = [null, 0, 0, null], area = ref[0], dx = ref[1], dy = ref[2], ninfo = ref[3];
      for (i = 0, len = neighbors.length; i < len; i++) {
        neighbor = neighbors[i];
        if (!(ninfo = this._items.get(neighbor))) {
          continue;
        }
        if (this._tested.get(neighbor) && indexOf.call(this._tested.get(neighbor), item) >= 0) {
          continue;
        }
        if (!_boxesIntersect.call(this, info.l, info.t, info.w, info.h, ninfo.l, ninfo.t, ninfo.w, ninfo.h)) {
          continue;
        }
        if (!this.shouldCollide(item, neighbor)) {
          continue;
        }
        ref1 = _getOverlapAndDisplacementVector.call(this, info.l, info.t, info.w, info.h, info.cx, info.cy, ninfo.l, ninfo.t, ninfo.w, ninfo.h, ninfo.cx, ninfo.cy), area = ref1[0], dx = ref1[1], dy = ref1[2];
        overlaps.push({
          neighbor: neighbor,
          area: area,
          dx: dx,
          dy: dy
        });
      }
      return overlaps;
    };

    _getMaximumAreaOverlap = function(overlaps) {
      var i, len, maxOverlap, overlap;
      if (overlaps.length === 0) {
        return [null, 0, 0];
      }
      maxOverlap = overlaps[0];
      for (i = 0, len = overlaps.length; i < len; i++) {
        overlap = overlaps[i];
        if (maxOverlap.area < overlap.area) {
          maxOverlap = overlap;
        }
      }
      return [maxOverlap.neighbor, maxOverlap.dx, maxOverlap.dy];
    };

    _boxesIntersect = function(l1, t1, w1, h1, l2, t2, w2, h2) {
      return l1 < l2 + w2 && l1 + w1 > l2 && t1 < t2 + h2 && t1 + h1 > t2;
    };

    _getOverlapAndDisplacementVector = function(l1, t1, w1, h1, c1x, c1y, l2, t2, w2, h2, c2x, c2y) {
      var area, ax, ay, dx, dy, ref;
      dx = l2 - l1 + (c1x < c2x ? -w1 : w2);
      dy = t2 - t1 + (c1y < c2y ? -h1 : h2);
      ref = [Math.abs(dx), Math.abs(dy)], ax = ref[0], ay = ref[1];
      area = ax * ay;
      if (ax < ay) {
        return [area, dx, 0];
      } else {
        return [area, 0, dy];
      }
    };

    _invokeEndCollision = function() {
      var i, item, len, neighbor, neighbors, ref, results;
      ref = this._prevCollisions.keys();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        neighbors = this._prevCollisions.get(item);
        if (this._items.get(item)) {
          results.push((function() {
            var j, len1, results1;
            results1 = [];
            for (j = 0, len1 = neighbors.length; j < len1; j++) {
              neighbor = neighbors[j];
              if (this._items.get(neighbor)) {
                results1.push(this.endCollision(item, neighbor));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Bump;

  })();

  lib.Bump = Bump;

}).call(this);

//# sourceMappingURL=bump.js.map
